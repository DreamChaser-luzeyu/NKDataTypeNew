þ©ÑTML>

<HEAD>

<LINK rel="stylesheet" href="../exer.css">

</HEAD>

<BODY>

<H1>

Data Structures, Algorithms, & Applications in C++<BR>

Chapter 13, Exercise 9<BR>

<BR>

</H1>



<dl compact>

<dt> (a)

<dd>

The completion times are (4, 6, 14, 15).

So, the ACT is (4 + 6 + 14 + 15) / 4) = 9.75.

<br><br>

<dt> (b)

<dd>

When the task order is 2, 1, 4, 3, the completion times are

(2, 6, 7, 15).  Now, the ACT is (2 + 6 + 7 + 15) / 4 = 7.5.

<br><br>

<dt>(c)

<dd>

For the greedy order 4, 2, 1, 3, the!—ú÷pletion times are

(1, 3, 7, 15).  The ACT for this order is 26 / 4 = 6.5.

<br><br>

<dt>(d)

<dd>

The greedy strategy can be implemented in <em class=var>n log n</em>

time by using an O(<em class=var>n log n</em>) sorting algorithm to first

sort the tasks into ascending order of task time.  This sorted order

is the order in which the tasks are to be done.

The code for the ACT function is given below.



<HR class = coderule>

<pre class = code>

template &lt;class T&gt;

void ACT(T J[], int n)

{.ÛµÉeorder the n tasks so that the average

 // completion time is minimized

   HeapSort(J,n);

}

<hr class=coderule>

</pre>

<br><br>



The code and a sample test can be found in the files

<em class=var>act1.*</em>.

<br><br>

<dt>(e)

<dd>

Since there are only <em class=var>n!</em> orders in which the

<em class=var>n</em> tasks can be done,

there must be one with minimum ACT.  Let <em class=var>S</em> denote the order that

gives minimum ACT.

Consider the tasks in the order given by <em class=var?§©³em>.

Suppose there is an <em class=var>i</em> for which

<em class=var>t<sub>i</sub></em> &gt;

<em class=var>t<sub>i+1</sub></em>.  Let <em class=var>A</em> = <em class=var>t<sub>1</sub> + t<sub>2</sub> + ... + t<sub>i-1</sub></em>.

The ACT of <em class=var>S</em> is

<br><br>

<em class=var>

((c<sub>1</sub> + ... + c<sub>i-1</sub>) + c<sub>i</sub> + c<sub>i+1</sub> +

(c<sub>i+2</sub> + ... + c<sub>n</sub>)) / n

<br>

= ((c<sub>1</sub> + ... + c<sub>i-1</sub>) + A + t<sub>i</sub> + A + t<sub>i</sucÊµ¶ t<sub>i+1</sub> +

(c<sub>i+2</sub> + ... + c<sub>n</sub>)) / n

<br>

=

((c<sub>1</sub> + ... + c<sub>i-1</sub>) + 2A + 2t<sub>i</sub> + t<sub>i+1</sub> +

(c<sub>i+2</sub> + ... + c<sub>n</sub>)) / n</em>.

<br><br>

If we swap tasks

<em class=var>i</em> and

<em class=var>i+1</em>, the ACT becomes

<em class=var>

((c<sub>1</sub> + ... c<sub>i-1</sub>) + 2A + t<sub>i</sub> + 2t<sub>i+1</sub> +

(c<sub>i+2</sub> + ... + c<sub>n</sub>)) / n</em>.

Since <em class=var>t<sub>i</sub></em> &gt;

<em clar‡¨èar>t<sub>i+1</sub></em>, the ACT is reduced as a result of the swap.

So, <em class=var>S</em> does not have minimum ACT.  This contradicts the assumption that

<em class=var>S</em> has minimum ACT.  So, there can be no

<em class=var>i</em>, in <em class=var>S</em>,

for which

<em class=var>t<sub>i</sub></em> &gt;

<em class=var>t<sub>i+1</sub></em>.  As a result, the tasks in

<em class=var>S</em> are in nondecreasing

order of task times.

<br><br>

When several tasks have the same task time, the rem•áöve order of these

does not affect the ACT.  So, any sorted order may be used.  As a result,

the task order generated by the greedy strategy of (c)

has minmum ACT.





</FONT>

</BODY>

</HTML>

